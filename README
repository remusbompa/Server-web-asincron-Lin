/* BOMPA REMUS 335CB */

1) Explicație pentru structura creată (sau soluția de ansamblu aleasă)
-comunicarea in retea, de la client la server se realizeaza in mod nonblocant folosind socketi
nonblocanti: la crearea unei noi conexiuni se foloseste apelul
	fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);
- in cazul fisierelor statice se trimite nonblocant direct din kernel folosind API de zero
-copying sendfile
- in cazul fisierelor dinamice datele se trimit asincron folosind functiile din familia io_setup
- primirea notificarilor despre posibilitatea trimiterii/ primirii pe socketii nonblocanti si
a terminarii operatiilor asincrone se face prin epoll

-exista 3 cazuri in care programul se poate afla, fiecare avand niste stari:
	-initial programul se afla in cazul 0, iar la primirea unei cereri de la un client se apeleaza
functia handle_client_request
	-functia analizeaza cereaza apeland receive_request iar daca se intoarce STATE_DATA_RECEIVED,
se verifica calea salvata in request_path:
	*)nu este valida => caz 0 
	*)are ca prefix directorul static => caz 1
	*)are ca prefix directorul dynamic => caz 2
	*)nu are un prefix valid => caz 0
	-functia repune socketul in epoll cu flagul de POLLOUT
	-se primeste notificare de POLLOUT si se verifica pe ce caz sunt:
		*)caz 0 => trimit mesaj de eroare si inchid conexiunea
		*)caz 1 => trimit antetul mesajului si ma duc in starea 1. In starea 1 trimit cu sendfile
		cate BUFSIZ octeti pana se terimina si inchid apoi conexiunea
		*)caz 1 => trimit antetul mesajului si ma duc in starea 1. In starea 1 se apeleaza functia
		send_file_aio care aloca un numar suficient de buffere astfel incat sa acopere dimensiunea
		fisierului impreuna, fiecare buffer va citi asincron prin apelul io_prep_pread si apoi
		io_submit un anumit segemnt din fisier, se intra in starea 2. Deoarece la un apel io_submit
		nu sunt submise neaparat toate operatiile de citire in buffere, aceasta stare poate sa se
		repete. In starea 2, se trimite urmatorul buffer, in care s-a finaliza citirea, pe socket.
		Cand s-au primit atatea buffere cat s-au trimis, inseamna ca s-au trimis toate segmentele
		submise, si se mai face o submisie. Cand s-a trimis numarul total de buffere, se inchide
		conexiunea

2) Implementare
- am implementat intregul enunt al temei

3) Cum se compilează și cum se rulează?
- am folosit fisierele puse la dispozitie in scheletul temei:
		http_parser.c, http_parser.h
		sock_util.c, sock_util.h
		debug.h, util.h, w_epoll.h, aws.h
	-makefile-ul obtine mai intai fisiere obiect pentru http_parser.c, sock_util.c si aws.c
	-cele 3 fisere obiect obtinute sunt apoi linkate cu bibliotea dinamic libaio pentru folosirea
functiilor asincrone din libaio.hHHTP
	-dintr-un terminal se ruleaza serverul ./aws iar din altul se pot trimite comenzi HTTP pentru
a cere trimiterea unui fisier

4) Bibliografie
*) https://ocw.cs.pub.ro/courses/so/laboratoare/laborator-11
